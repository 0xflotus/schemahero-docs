{"componentChunkName":"component---node-modules-gatsby-theme-apollo-docs-src-components-template-js","path":"/comparisons/sequential-migrations/","result":{"data":{"site":{"pathPrefix":"/learn","siteMetadata":{"title":"Learn SchemaHero","description":"Learn SchemaHero"}},"file":{"childMarkdownRemark":{"frontmatter":{"title":"Sequential Migrations","description":"Comparing SchemaHero's declarative model to sequence migrations"},"headings":[],"fields":{"image":"social-cards/sequential-migrations.png","graphManagerUrl":""},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Sequential Migration and Replay schema management tools work by allowing the developer to create a series of migration files that will be executed in order at migration time.\nAfter a system is running, a new migration file cab be added to the stack to be deployed.\nThis is an imperative pattern; a developer writes intructions that the will be executed, with the intent of producing a desired schema."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Examples"}]},{"type":"text","value":"  "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/db-migrate/node-db-migrate"},"children":[{"type":"text","value":"db-migrate"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://flywaydb.org/"},"children":[{"type":"text","value":"Flyaway"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/pressly/goose"},"children":[{"type":"text","value":"goose"}]},{"type":"text","value":" "}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Challenges"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"These tools work nicely at first, but create some operational challenges over time:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"When a feature of the database engine is no longer used by the application, all newly installed database instances must have supoprt for this unused feature in order to allow this migration to succeed.\nFor example, if using Postgres and an extension is required and used for a while and and then removed, the database migations will fail to run on a new database unless that extension is present, even though it's not needed in the end state.\nThis can be solved by manually refactoring old migrations to remove the dependency on the unused feature."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Creating new environments becomes slow and brittle over time.\nIn a product that's rapidly iterating there can be hundreds of migrations.\nReplaying these can be slow and any single failed migration will break the deployment."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Database upgrades create incompatible migrations.\nAfter upgrading a database version, the syntax supported may change.\nThis can leave older migrations unable to be applied against the current version of the databse when creating a new environment."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Concurrent changes can create conflicts or skipped migrations.\nThese tools often employ a sequential (integer) counter or a timestamp. When multiple migrations are simultaneously prepared offline, these may have the same counter value or be commited in a different order than they were generated.\nThis can cause the runtime to skip a migration."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"workarounds","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#workarounds","ariaLabel":"workarounds permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"Workarounds"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To help solve this, manual intervention is often taken to \"rebase\" and refactor the migration history.\nThis is equivalent to retrieving a current schema from the database, deleting all migrations, and creating a single migration.\nThis is a manual process that must be run periodically when using a sequential migration strategy."}]}],"data":{"quirksMode":false}}},"childMdx":null}},"pageContext":{"id":"4981069a-c7dd-5c4b-be54-bfaa0da7788c","subtitle":"Learn SchemaHero","versionDifference":0,"versionBasePath":"/vdefault","sidebarContents":[{"title":null,"pages":[{"title":"Learning SchemaHero","description":"Learning SchemaHero","path":"/"},{"title":"Declarative Schema Management","description":"An explanation of the declarative schema management concept","path":"/declarative-schema-management/"},{"title":"Data Migrations","description":"Comparing Data and Schema Migrations","path":"/data-migrations/"}]},{"title":"Tutorial","pages":[{"title":"Introduction","description":"Start here to understand the SchemaHero tutorial","path":"/tutorial/introduction/"},{"title":"Install SchemaHero","description":"Learn how to install the SchemaHero kubectl plugin and the in-cluster Operator","path":"/tutorial/install-schemahero/"},{"title":"Connect A Database","description":"Learn how to configure SchemaHero to manage a database","path":"/tutorial/connect-database/"},{"title":"Create A New Table","description":"Learn how to create a new table using SchemaHero","path":"/tutorial/create-table/"},{"title":"Modify Table","description":"Modify Table","path":"/tutorial/modify-table/"},{"title":"Next Steps","description":"Next Steps","path":"/tutorial/next-steps/"}]},{"title":"Comparisons","pages":[{"title":"Sequential Migrations","description":"Comparing SchemaHero's declarative model to sequence migrations","path":"/comparisons/sequential-migrations/"},{"title":"ORM","description":"Comparing SchemaHero to an ORM (Object Relational Mapper)","path":"/comparisons/orm/"}]}],"githubUrl":"https://github.com/schemahero/schemahero/tree/master/learn/source/comparisons/sequential-migrations.md","twitterHandle":"schemahero","versions":[],"defaultVersion":"default","baseUrl":"https://schemahero.io"}}}